/// <reference types="node" />
import { EventEmitter } from 'events';
import fs from 'fs';
export interface Information {
    chapter: number;
    chapters: number[];
    title: number;
    category: Category;
    titles: number[];
}
export interface Category {
    meta: Meta;
    [flux: string]: {
        [key: string]: string;
    } | Meta;
}
export interface Flux {
    [flux: string]: string;
}
export interface Audiofilters {
    [filter: string]: string;
}
export interface Meta {
    encoded_by: string;
    filename: string;
}
export interface Videoeffects {
    hue: number;
    saturation: number;
    contrast: number;
    brightness: number;
    gamma: number;
}
declare type Stats = {
    [key: string]: number;
};
declare type AspectRatio = '1:1' | '4:3' | '5:4' | '16:9' | '16:10' | '221:100' | '235:100' | '239:100';
declare type State = 'paused' | 'playing' | 'stopped';
declare type StatusBase = {
    fullscreen: boolean;
    stats: Stats | null;
    aspectratio: AspectRatio | null;
    audiodelay: number;
    apiversion: number;
    currentplid: number;
    time: number;
    volume: number;
    length: number;
    random: boolean;
    audiofilters: Audiofilters;
    rate: number;
    videoeffects: Videoeffects;
    state: State;
    loop: boolean;
    version: string;
    position: number;
    information: Information;
    repeat: boolean;
    subtitledelay: number;
    equalizer: any[];
};
declare type StatusPaused = StatusBase & {
    stats: Stats;
    aspectratio: AspectRatio;
    state: 'paused';
};
declare type StatusPlaying = StatusBase & {
    stats: Stats;
    aspectratio: AspectRatio;
    state: 'playing';
};
declare type StatusStopped = StatusBase & {
    stats: null;
    aspectratio: null;
    state: 'stopped';
};
declare type Status = StatusPaused | StatusPlaying | StatusStopped;
declare type BrowseElement = {
    type: 'dir' | 'file';
    path: string;
    name: string;
    uid: number;
    creation_time: number;
    gid: number;
    modification_time: number;
    mode: number;
    uri: string;
    size: number;
};
declare type Browse = {
    elements: BrowseElement[];
};
declare type PlaylistBase = {
    ro: 'rw' | 'ro';
    type: 'node' | 'leaf';
    name: string;
    id: string;
    children?: any[];
    duration?: number;
    uri?: string;
};
declare type PlaylistLeaf = PlaylistBase & {
    duration: number;
    uri: string;
};
declare type PlaylistNode = PlaylistBase & {
    children: (PlaylistNode | PlaylistLeaf)[];
};
declare type Playlist = PlaylistNode | PlaylistLeaf;
export declare type VLCOptions = {
    host?: string;
    port?: number;
    username: string;
    password: string;
    /** update automatically status and playlist of VLC, default true. */
    autoUpdate?: boolean;
    /** how many times per seconds (in ms) node-vlc-http will update the status of VLC, default 1000/30 ~ 33ms (30fps). */
    tickLengthMs?: number;
    /**
     * checks that browse, status and playlist have changed since the last update of one of its elements,
     * if it the case fire browsechange, statuschange or playlistchange event. default true.
     */
    changeEvents?: boolean;
    /** max tries at the first connection before throwing an error set it to -1 for infinite try, default 3 */
    maxTries?: number;
    /** interval between two try in ms, default 1000 */
    triesInterval?: number;
};
export declare interface VLC {
    on(event: 'tick', listener: (delta: number) => void): this;
    on(event: 'update', listener: (status: Status, playlist: any) => void): this;
    on(event: 'statuschange', listener: (prev: Status, next: Status) => void): this;
    on(event: 'playlistchange', listener: (prev: any, next: any) => void): this;
    on(event: 'error', listener: (err: Error) => void): this;
    /** fired when connected */
    on(event: 'connect', listener: () => void): this;
    on(event: string | symbol, listener: (...args: any[]) => void): this;
}
export declare class VLC extends EventEmitter {
    private _host;
    private _port;
    private _autoUpdate;
    private _changeEvents;
    private _authorization;
    private _tickLengthMs;
    private _tickLengthNano;
    private _longWaitMs;
    private _longWaitNano;
    private _prev;
    private _target;
    private _status;
    private _playlist;
    private _maxTries;
    private _triesInterval;
    constructor(options: VLCOptions);
    private _connect;
    private _doTick;
    private _sendCommand;
    browse(path: string): Promise<Browse>;
    updateStatus(): Promise<Status>;
    updatePlaylist(): Promise<Playlist>;
    updateAll(): Promise<[Status, Playlist]>;
    /**
     * Add `uri` to playlist and start playback.
     */
    addToQueueAndPlay(uri: fs.PathLike, option?: 'noaudio' | 'novideo'): Promise<Status>;
    /**
     * Add `uri` to playlist.
     */
    addToQueue(uri: fs.PathLike): Promise<Status>;
    /**
     * Add subtitle to currently playing file.
     */
    addSubtitle(uri: fs.PathLike): Promise<Status>;
    /**
     * Play playlist item `id`. If `id` is omitted, play last active item.
     */
    play(id: number): Promise<Status>;
    /**
     * Toggle pause. If current state was 'stop', play item `id`, if `id` is omitted, play current item.
     * If no current item, play 1st item in the playlist.
     */
    pause(id: number): Promise<Status>;
    /**
     * Stop playback.
     */
    stop(): Promise<Status>;
    /**
     * Resume playback if state was 'paused', else do nothing.
     */
    resume(): Promise<Status>;
    /**
     * Pause playback, do nothing if state was 'paused'.
     */
    forcePause(): Promise<Status>;
    /**
     * Jump to next item in playlist.
     */
    playlistNext(): Promise<Status>;
    /**
     * Jump to previous item in playlist.
     */
    playlistPrevious(): Promise<Status>;
    /**
     * Delete item `id` from playlist.
     */
    playlistDelete(id: number): Promise<Status>;
    /**
     * Empty playlist.
     */
    playlistEmpty(): Promise<Status>;
    /**
     * Sort playlist using sort mode `mode` and order `order`.
     * If `order` = 0 then items will be sorted in normal order, if `order` = 1 ` they will be sorted in reverse order.
     * A non exhaustive list of sort modes:
     *  0 Id
     *  1 Name
     *  3 Author
     *  5 Random
     *  7 Track number
     */
    sortPlaylist(order: 0 | 1, mode: 0 | 1 | 3 | 5 | 7): Promise<Status>;
    /**
     * Set audio delay.
     */
    setAudioDelay(delay: number): Promise<Status>;
    /**
     * Set subtitle delay.
     */
    setSubtitleDelay(delay: number): Promise<Status>;
    /**
     * Set playback rate.
     */
    setPlaybackRate(rate: number): Promise<Status>;
    /**
     * Set aspect ratio.
     */
    setAspectRatio(ratio: AspectRatio): Promise<Status>;
    /**
     * Set volume level to `volume`.
     */
    setVolume(volume: number | string): Promise<Status>;
    /**
     * Set the preamp value.
     */
    setPreamp(value: number): Promise<Status>;
    /**
     * Set the gain for a specific band.
     */
    setEqualizer(band: number, gain: number): Promise<Status>;
    /**
     * Set the equalizer preset as per the `id` specified.
     */
    setEqualizerPreset(id: number): Promise<Status>;
    /**
     * Toggle random playback.
     */
    toggleRandom(): Promise<Status>;
    /**
     * Toggle loop.
     */
    toggleLoop(): Promise<Status>;
    /**
     * Toggle repeat.
     */
    toggleRepeat(): Promise<Status>;
    /**
     * Toggle fullscreen.
     */
    toggleFullscreen(): Promise<Status>;
    /**
     * Seek to `time`.
     * @return  {Promise<object>}
     */
    seek(time: number): Promise<Status>;
    /**
     * Seek to chapter `chapter`.
     */
    seekToChapter(chapter: number): Promise<Status>;
}
export {};
