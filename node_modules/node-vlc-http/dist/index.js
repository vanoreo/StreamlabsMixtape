"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.VLC = void 0;
const events_1 = require("events");
const url_1 = require("url");
const http_1 = __importDefault(require("http"));
const querystring_1 = __importDefault(require("querystring"));
var CommandScope;
(function (CommandScope) {
    CommandScope["BROWSE"] = "/requests/browse.json";
    CommandScope["STATUS"] = "/requests/status.json";
    CommandScope["PLAYLIST"] = "/requests/playlist.json";
})(CommandScope || (CommandScope = {}));
const waitFor = (ms) => new Promise(resolve => setTimeout(resolve, ms));
const pathlikeToString = (path) => {
    if (Buffer.isBuffer(path)) {
        return path.toString('utf8');
    }
    else if (path instanceof url_1.URL) {
        return path.href;
    }
    return path;
};
const s2nano = 1e9;
const ms2nano = 1e6;
const nano2s = 1 / s2nano;
function getNano() {
    const hrtime = process.hrtime();
    return +hrtime[0] * s2nano + +hrtime[1];
}
function get(options) {
    return new Promise((resolve, reject) => {
        const req = http_1.default.get(options, response => {
            let data = '';
            response.on('error', reject);
            response.on('data', chunk => (data += chunk));
            response.on('end', () => {
                if (response.statusCode !== 200) {
                    return reject(new Error(`${response.statusCode} ${response.statusMessage || 'HTTPError'}`));
                }
                try {
                    resolve(JSON.parse(data));
                }
                catch (err) {
                    reject(err);
                }
            });
        });
        req.on('error', reject);
    });
}
function isObject(obj) {
    if (typeof obj === 'object' && obj != null) {
        return true;
    }
    else {
        return false;
    }
}
function equal(a, b) {
    if (a === b) {
        return true;
    }
    else if (isObject(a) && isObject(b)) {
        if (Object.keys(a).length !== Object.keys(b).length) {
            return false;
        }
        for (var prop in a) {
            if (!equal(a[prop], b[prop])) {
                return false;
            }
        }
        return true;
    }
    return false;
}
class VLC extends events_1.EventEmitter {
    constructor(options) {
        super();
        this._autoUpdate = true;
        this._changeEvents = true;
        this._status = null;
        this._playlist = null;
        this._maxTries = -1;
        this._triesInterval = 1000;
        this._host = options.host || '127.0.0.1';
        this._port = options.port || 8080;
        if (typeof options.autoUpdate === 'boolean') {
            this._autoUpdate = options.autoUpdate;
        }
        if (typeof options.changeEvents === 'boolean') {
            this._changeEvents = options.changeEvents;
        }
        this._tickLengthMs = options.tickLengthMs || 1000 / 30;
        // node leaks memory if setTimeout is called with a value less than 16
        if (this._tickLengthMs < 16) {
            this._tickLengthMs = 16;
        }
        this._maxTries = options.maxTries || 3;
        this._triesInterval = options.triesInterval || 1000;
        this._tickLengthNano = this._tickLengthMs * ms2nano;
        this._longWaitMs = Math.floor(this._tickLengthMs - 1);
        this._longWaitNano = this._longWaitMs * ms2nano;
        this._prev = getNano();
        this._target = this._prev;
        // generate authorization string
        this._authorization = `Basic ${Buffer.from(`${options.username}:${options.password}`).toString('base64')}`;
        // check if VLC is up
        this._connect()
            .then(() => {
            this.emit('connect');
            if (this._autoUpdate)
                this._doTick();
        })
            .catch(this.emit.bind(this, 'error'));
    }
    async _connect() {
        if (this._maxTries === 0)
            await this._sendCommand(CommandScope.STATUS);
        else if (this._maxTries === -1) {
            while (true) {
                try {
                    await this._sendCommand(CommandScope.STATUS);
                }
                catch (_) {
                    await waitFor(this._triesInterval);
                    continue;
                }
                break;
            }
        }
        else {
            for (let i = 1; i < this._maxTries; i++) {
                try {
                    await this._sendCommand(CommandScope.STATUS);
                }
                catch (_) {
                    await waitFor(this._triesInterval);
                    continue;
                }
                return;
            }
            await this._sendCommand(CommandScope.STATUS);
        }
    }
    _doTick() {
        const now = getNano();
        if (now >= this._target) {
            const delta = (now - this._prev) * nano2s;
            this._prev = now;
            this._target = now + this._tickLengthNano;
            this.emit('tick', delta);
            this.updateAll().catch(err => this.emit('error', err));
        }
        const remainingInTick = this._target - getNano();
        if (remainingInTick > this._longWaitNano) {
            setTimeout(this._doTick.bind(this), Math.max(this._longWaitMs, this._tickLengthMs));
        }
        else {
            setImmediate(this._doTick.bind(this));
        }
    }
    async _sendCommand(scope, command, options) {
        let query = null;
        if (command) {
            query = querystring_1.default.stringify({ command, ...options });
        }
        else if (!command && query) {
            query = querystring_1.default.stringify(options);
        }
        return get({
            host: this._host,
            port: this._port,
            path: `${scope}${query ? `?${query}` : ''}`,
            headers: {
                Authorization: this._authorization
            }
        });
    }
    async browse(path) {
        const browse = this._sendCommand(CommandScope.BROWSE, null, {
            dir: path
        });
        return browse;
    }
    async updateStatus() {
        const status = await this._sendCommand(CommandScope.STATUS);
        if (this._changeEvents && !equal(status, this._status)) {
            try {
                this.emit('statuschange', this._status || status, status);
            }
            catch (err) {
                this.emit('error', err);
            }
            this._status = status;
        }
        return status;
    }
    async updatePlaylist() {
        const playlist = await this._sendCommand(CommandScope.PLAYLIST);
        if (this._changeEvents && !equal(playlist, this._playlist)) {
            try {
                this.emit('playlistchange', this._playlist || playlist, playlist);
            }
            catch (err) {
                this.emit('error', err);
            }
            this._playlist = playlist;
        }
        return playlist;
    }
    async updateAll() {
        const [status, playlist] = await Promise.all([
            this.updateStatus(),
            this.updatePlaylist()
        ]);
        try {
            this.emit('update', status, playlist);
        }
        catch (err) {
            this.emit('error', err);
        }
        return [status, playlist];
    }
    /**
     * Add `uri` to playlist and start playback.
     */
    addToQueueAndPlay(uri, option) {
        return this._sendCommand(CommandScope.STATUS, 'in_play', {
            input: pathlikeToString(uri),
            option
        });
    }
    /**
     * Add `uri` to playlist.
     */
    addToQueue(uri) {
        return this._sendCommand(CommandScope.STATUS, 'in_enqueue', {
            input: pathlikeToString(uri)
        });
    }
    /**
     * Add subtitle to currently playing file.
     */
    addSubtitle(uri) {
        return this._sendCommand(CommandScope.STATUS, 'addsubtitle', {
            input: pathlikeToString(uri)
        });
    }
    /**
     * Play playlist item `id`. If `id` is omitted, play last active item.
     */
    play(id) {
        return this._sendCommand(CommandScope.STATUS, 'pl_play', { id });
    }
    /**
     * Toggle pause. If current state was 'stop', play item `id`, if `id` is omitted, play current item.
     * If no current item, play 1st item in the playlist.
     */
    pause(id) {
        return this._sendCommand(CommandScope.STATUS, 'pl_pause', { id });
    }
    /**
     * Stop playback.
     */
    stop() {
        return this._sendCommand(CommandScope.STATUS, 'pl_forcepause');
    }
    /**
     * Resume playback if state was 'paused', else do nothing.
     */
    resume() {
        return this._sendCommand(CommandScope.STATUS, 'pl_forceresume');
    }
    /**
     * Pause playback, do nothing if state was 'paused'.
     */
    forcePause() {
        return this._sendCommand(CommandScope.STATUS, 'pl_forcepause');
    }
    /**
     * Jump to next item in playlist.
     */
    playlistNext() {
        return this._sendCommand(CommandScope.STATUS, 'pl_next');
    }
    /**
     * Jump to previous item in playlist.
     */
    playlistPrevious() {
        return this._sendCommand(CommandScope.STATUS, 'pl_previous');
    }
    /**
     * Delete item `id` from playlist.
     */
    playlistDelete(id) {
        return this._sendCommand(CommandScope.STATUS, 'pl_delete', { id });
    }
    /**
     * Empty playlist.
     */
    playlistEmpty() {
        return this._sendCommand(CommandScope.STATUS, 'pl_empty');
    }
    /**
     * Sort playlist using sort mode `mode` and order `order`.
     * If `order` = 0 then items will be sorted in normal order, if `order` = 1 ` they will be sorted in reverse order.
     * A non exhaustive list of sort modes:
     *  0 Id
     *  1 Name
     *  3 Author
     *  5 Random
     *  7 Track number
     */
    sortPlaylist(order, mode) {
        return this._sendCommand(CommandScope.STATUS, 'pl_sort', {
            id: mode,
            val: order
        });
    }
    /**
     * Set audio delay.
     */
    setAudioDelay(delay) {
        return this._sendCommand(CommandScope.STATUS, 'audiodelay', { val: delay });
    }
    /**
     * Set subtitle delay.
     */
    setSubtitleDelay(delay) {
        return this._sendCommand(CommandScope.STATUS, 'subdelay', { val: delay });
    }
    /**
     * Set playback rate.
     */
    setPlaybackRate(rate) {
        return this._sendCommand(CommandScope.STATUS, 'rate', { val: rate });
    }
    /**
     * Set aspect ratio.
     */
    setAspectRatio(ratio) {
        return this._sendCommand(CommandScope.STATUS, 'aspectratio', {
            val: ratio
        });
    }
    /**
     * Set volume level to `volume`.
     */
    setVolume(volume) {
        return this._sendCommand(CommandScope.STATUS, 'volume', { val: volume });
    }
    /**
     * Set the preamp value.
     */
    setPreamp(value) {
        return this._sendCommand(CommandScope.STATUS, 'preamp', { val: value });
    }
    /**
     * Set the gain for a specific band.
     */
    setEqualizer(band, gain) {
        return this._sendCommand(CommandScope.STATUS, 'equalizer', {
            band: band,
            val: gain
        });
    }
    /**
     * Set the equalizer preset as per the `id` specified.
     */
    setEqualizerPreset(id) {
        return this._sendCommand(CommandScope.STATUS, 'equalizer', { val: id });
    }
    /**
     * Toggle random playback.
     */
    toggleRandom() {
        return this._sendCommand(CommandScope.STATUS, 'pl_random');
    }
    /**
     * Toggle loop.
     */
    toggleLoop() {
        return this._sendCommand(CommandScope.STATUS, 'pl_loop');
    }
    /**
     * Toggle repeat.
     */
    toggleRepeat() {
        return this._sendCommand(CommandScope.STATUS, 'pl_repeat');
    }
    /**
     * Toggle fullscreen.
     */
    toggleFullscreen() {
        return this._sendCommand(CommandScope.STATUS, 'fullscreen');
    }
    /**
     * Seek to `time`.
     * @return  {Promise<object>}
     */
    seek(time) {
        return this._sendCommand(CommandScope.STATUS, 'seek', { val: time });
    }
    /**
     * Seek to chapter `chapter`.
     */
    seekToChapter(chapter) {
        return this._sendCommand(CommandScope.STATUS, 'chapter', { val: chapter });
    }
}
exports.VLC = VLC;
